/**
 * Job Controller
 * 
 * Handles all job-related API operations including:
 * - Creating one-time jobs
 * - Creating recurring jobs
 * - Retrieving job details
 * - Managing job lifecycle
 */

const Job = require('../models/Job');
const ApiResponse = require('../utils/ApiResponse');
const AppError = require('../utils/AppError');
const { validateOneTimeJob, validateRecurringJob } = require('../validators/jobValidator');

/**
 * @desc    Create a one-time job
 * @route   POST /api/jobs/one-time
 * @access  Private
 */
const createOneTimeJob = async (req, res, next) => {
    try {
        // Validate input
        const { isValid, errors, sanitizedData } = validateOneTimeJob(req.body);

        if (!isValid) {
            return ApiResponse.validationError(res, errors);
        }

        // Create job document
        const jobData = {
            ...sanitizedData,
            jobType: 'ONE_TIME',
            nextRunAt: sanitizedData.scheduleTime,
            status: 'SCHEDULED',
            createdBy: req.user?._id
        };

        // Handle dependency if present
        if (sanitizedData.dependsOnJobId) {
            const parentJob = await Job.findOne({ jobId: sanitizedData.dependsOnJobId, isActive: true });
            if (!parentJob) {
                return ApiResponse.notFound(res, `Parent job not found: ${sanitizedData.dependsOnJobId}`);
            }

            // Check for circular dependency (self-reference)
            // (Note: jobId here is generated by DB, but we don't have it yet. 
            // Since dependsOnJobId is existing ID, and we are creating NEW job, self-ref is impossible by ID.
            // But we can check if dependsOnJobId points to *this* logic? No, circularity happens in chains A->B->A
            // Checking immediate self-ref is irrelevant for creation, checking cycle is complex.)

            jobData.dependsOnJobId = parentJob._id;

            // Determine status
            if (parentJob.status === 'COMPLETED') {
                jobData.status = 'SCHEDULED';
            } else if (['FAILED', 'CANCELLED', 'BLOCKED'].includes(parentJob.status)) {
                jobData.status = 'BLOCKED';
            } else {
                jobData.status = 'WAITING';
            }
        }

        const job = await Job.create(jobData);

        // Return success response
        return ApiResponse.created(res, 'One-time job created successfully', {
            job: {
                jobId: job.jobId,
                jobName: job.jobName,
                jobType: job.jobType,
                taskType: job.taskType,
                scheduleTime: job.scheduleTime,
                status: job.status,
                priority: job.priority,
                maxRetries: job.maxRetries,
                createdAt: job.createdAt
            }
        });
    } catch (error) {
        next(error);
    }
};

/**
 * @desc    Create a recurring job
 * @route   POST /api/jobs/recurring
 * @access  Private
 */
const createRecurringJob = async (req, res, next) => {
    try {
        // Validate input
        const { isValid, errors, sanitizedData } = validateRecurringJob(req.body);

        if (!isValid) {
            return ApiResponse.validationError(res, errors);
        }

        // Calculate initial nextRunAt if not provided
        let nextRunAt = sanitizedData.nextRunAt;
        if (!nextRunAt) {
            if (sanitizedData.interval) {
                // For interval-based jobs, start immediately or after the interval
                nextRunAt = new Date(Date.now() + sanitizedData.interval);
            } else {
                // For cron-based jobs, calculate from cron expression
                // In production, use a library like 'cron-parser' for accurate calculation
                nextRunAt = new Date(); // Run immediately for now
            }
        }

        // Create job document
        const jobData = {
            ...sanitizedData,
            jobType: 'RECURRING',
            nextRunAt,
            status: 'SCHEDULED',
            createdBy: req.user?._id
        };

        // Handle dependency if present
        if (sanitizedData.dependsOnJobId) {
            const parentJob = await Job.findOne({ jobId: sanitizedData.dependsOnJobId, isActive: true });
            if (!parentJob) {
                return ApiResponse.notFound(res, `Parent job not found: ${sanitizedData.dependsOnJobId}`);
            }

            jobData.dependsOnJobId = parentJob._id;

            // Determine status
            if (parentJob.status === 'COMPLETED') {
                jobData.status = 'SCHEDULED';
            } else if (['FAILED', 'CANCELLED', 'BLOCKED'].includes(parentJob.status)) {
                jobData.status = 'BLOCKED';
            } else {
                jobData.status = 'WAITING';
            }
        }

        const job = await Job.create(jobData);

        // Return success response
        return ApiResponse.created(res, 'Recurring job created successfully', {
            job: {
                jobId: job.jobId,
                jobName: job.jobName,
                jobType: job.jobType,
                taskType: job.taskType,
                cronExpression: job.cronExpression,
                interval: job.interval,
                nextRunAt: job.nextRunAt,
                status: job.status,
                priority: job.priority,
                maxRetries: job.maxRetries,
                createdAt: job.createdAt
            }
        });
    } catch (error) {
        next(error);
    }
};

/**
 * @desc    Get all jobs (with pagination and filtering)
 * @route   GET /api/jobs
 * @access  Private
 */
const getAllJobs = async (req, res, next) => {
    try {
        const page = parseInt(req.query.page, 10) || 1;
        const limit = parseInt(req.query.limit, 10) || 10;
        const skip = (page - 1) * limit;

        // Build filter object
        const filter = { isActive: true };

        if (req.query.status) {
            filter.status = req.query.status.toUpperCase();
        }

        if (req.query.jobType) {
            filter.jobType = req.query.jobType.toUpperCase();
        }

        if (req.query.taskType) {
            filter.taskType = req.query.taskType;
        }

        if (req.query.search) {
            filter.$text = { $search: req.query.search };
        }

        // Execute query
        const [jobs, total] = await Promise.all([
            Job.find(filter)
                .sort({ createdAt: -1 })
                .skip(skip)
                .limit(limit)
                .select('-__v')
                .populate('dependsOnJobId', 'jobId jobName'),
            Job.countDocuments(filter)
        ]);

        return ApiResponse.success(res, 200, 'Jobs retrieved successfully', {
            jobs,
            pagination: {
                currentPage: page,
                totalPages: Math.ceil(total / limit),
                totalItems: total,
                itemsPerPage: limit
            }
        });
    } catch (error) {
        next(error);
    }
};

/**
 * @desc    Get single job by jobId
 * @route   GET /api/jobs/:jobId
 * @access  Private
 */
const getJobById = async (req, res, next) => {
    try {
        const job = await Job.findOne({ jobId: req.params.jobId, isActive: true })
            .populate('dependsOnJobId', 'jobId jobName');

        if (!job) {
            return ApiResponse.notFound(res, 'Job not found');
        }

        return ApiResponse.success(res, 200, 'Job retrieved successfully', { job });
    } catch (error) {
        next(error);
    }
};

/**
 * @desc    Cancel a job
 * @route   PATCH /api/jobs/:jobId/cancel
 * @access  Private
 */
const cancelJob = async (req, res, next) => {
    try {
        const job = await Job.findOne({ jobId: req.params.jobId, isActive: true });

        if (!job) {
            return ApiResponse.notFound(res, 'Job not found');
        }

        // Only allow cancellation if job is not already running or completed
        const nonCancellableStatuses = ['RUNNING', 'COMPLETED', 'CANCELLED'];
        if (nonCancellableStatuses.includes(job.status)) {
            return ApiResponse.badRequest(res, `Cannot cancel job with status: ${job.status}`);
        }

        job.status = 'CANCELLED';
        await job.save();

        // Block dependent jobs
        await Job.updateMany(
            { dependsOnJobId: job._id, status: 'WAITING' },
            { $set: { status: 'BLOCKED' } }
        );

        return ApiResponse.success(res, 200, 'Job cancelled successfully', {
            job: {
                jobId: job.jobId,
                status: job.status
            }
        });
    } catch (error) {
        next(error);
    }
};

/**
 * @desc    Pause a recurring job
 * @route   PATCH /api/jobs/:jobId/pause
 * @access  Private
 */
const pauseJob = async (req, res, next) => {
    try {
        const job = await Job.findOne({
            jobId: req.params.jobId,
            isActive: true
        });

        if (!job) {
            return ApiResponse.notFound(res, 'Job not found');
        }

        if (job.status === 'PAUSED') {
            return ApiResponse.badRequest(res, 'Job is already paused');
        }

        if (job.status === 'RUNNING') {
            return ApiResponse.badRequest(res, 'Cannot pause a running job. Wait for it to complete.');
        }

        await job.pause();

        return ApiResponse.success(res, 200, 'Job paused successfully', {
            job: {
                jobId: job.jobId,
                status: job.status
            }
        });
    } catch (error) {
        next(error);
    }
};

/**
 * @desc    Resume a paused job
 * @route   PATCH /api/jobs/:jobId/resume
 * @access  Private
 */
const resumeJob = async (req, res, next) => {
    try {
        const job = await Job.findOne({
            jobId: req.params.jobId,
            isActive: true
        });

        if (!job) {
            return ApiResponse.notFound(res, 'Job not found');
        }

        if (job.status !== 'PAUSED') {
            return ApiResponse.badRequest(res, 'Only paused jobs can be resumed');
        }

        await job.resume();

        return ApiResponse.success(res, 200, 'Job resumed successfully', {
            job: {
                jobId: job.jobId,
                status: job.status
            }
        });
    } catch (error) {
        next(error);
    }
};

/**
 * @desc    Update a job
 * @route   PUT /api/jobs/:jobId
 * @access  Private
 */
const updateJob = async (req, res, next) => {
    try {
        const job = await Job.findOne({ jobId: req.params.jobId, isActive: true });

        if (!job) {
            return ApiResponse.notFound(res, 'Job not found');
        }

        // Validate based on job type (or new job type if provided)
        const jobType = req.body.jobType || job.jobType;
        let validationResult;

        // Ensure priority is set correctly if it comes as string
        if (req.body.priority) {
            req.body.priority = parseInt(req.body.priority);
        }

        if (jobType === 'ONE_TIME') {
            validationResult = validateOneTimeJob({ ...req.body, jobType });
        } else {
            validationResult = validateRecurringJob({ ...req.body, jobType });
        }

        const { isValid, errors, sanitizedData } = validationResult;

        if (!isValid) {
            return ApiResponse.validationError(res, errors);
        }

        // Update fields
        job.jobName = sanitizedData.jobName;
        job.taskType = sanitizedData.taskType;
        job.jobType = jobType;
        if (sanitizedData.description) job.description = sanitizedData.description;
        if (sanitizedData.payload) job.payload = sanitizedData.payload;
        if (sanitizedData.priority) job.priority = sanitizedData.priority;
        if (sanitizedData.maxRetries !== undefined) job.maxRetries = sanitizedData.maxRetries;
        if (sanitizedData.retryDelay) job.retryDelay = sanitizedData.retryDelay;
        if (sanitizedData.tags) job.tags = sanitizedData.tags;
        if (sanitizedData.timezone) job.timezone = sanitizedData.timezone;

        // Update schedule-specific fields
        if (jobType === 'ONE_TIME') {
            job.scheduleTime = sanitizedData.scheduleTime;
            job.nextRunAt = sanitizedData.scheduleTime;

            // If updating a completed/failed job to a new time, reset status
            if (['COMPLETED', 'FAILED'].includes(job.status)) {
                job.status = 'SCHEDULED';
            }
        } else {
            job.cronExpression = sanitizedData.cronExpression;
            if (sanitizedData.interval) job.interval = sanitizedData.interval;
            if (sanitizedData.startTime) job.startTime = sanitizedData.startTime;
            if (sanitizedData.endTime) job.endTime = sanitizedData.endTime;

            // Recalculate nextRunAt if needed
            if (sanitizedData.nextRunAt) {
                job.nextRunAt = sanitizedData.nextRunAt;
            } else if (!job.nextRunAt || job.nextRunAt < new Date()) {
                // Reschedule if needed
                if (job.interval) {
                    job.nextRunAt = new Date(Date.now() + job.interval);
                } else {
                    job.nextRunAt = new Date(); // Immediate for cron
                }
                job.status = 'SCHEDULED';
            }
        }

        await job.save();

        return ApiResponse.success(res, 200, 'Job updated successfully', {
            job: {
                jobId: job.jobId,
                jobName: job.jobName,
                jobType: job.jobType,
                taskType: job.taskType,
                status: job.status,
                nextRunAt: job.nextRunAt,
                updatedAt: job.updatedAt
            }
        });
    } catch (error) {
        next(error);
    }
};

/**
 * @desc    Delete a job (soft delete)
 * @route   DELETE /api/jobs/:jobId
 * @access  Private
 */
const deleteJob = async (req, res, next) => {
    try {
        const job = await Job.findOne({ jobId: req.params.jobId, isActive: true });

        if (!job) {
            return ApiResponse.notFound(res, 'Job not found');
        }

        if (job.status === 'RUNNING') {
            return ApiResponse.badRequest(res, 'Cannot delete a running job');
        }

        // Soft delete
        job.isActive = false;
        job.status = 'CANCELLED';
        // Auto-delete after 5 days
        job.expireAt = new Date(Date.now() + 5 * 24 * 60 * 60 * 1000);
        await job.save();

        return ApiResponse.success(res, 200, 'Job deleted successfully', {
            jobId: job.jobId
        });
    } catch (error) {
        next(error);
    }
};

module.exports = {
    createOneTimeJob,
    createRecurringJob,
    getAllJobs,
    getJobById,
    updateJob,
    cancelJob,
    pauseJob,
    resumeJob,
    deleteJob
};
